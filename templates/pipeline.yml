AWSTemplateFormatVersion: "2010-09-09"
Description: Infrastructure for CloudFormation templates, e.g. pipeline and bucket 
Parameters:
  GithubOauthToken:
    Type: String
  GithubRepoOwner:
    Type: String
  GithubRepoName:
    Type: String
  GithubRepoBranch:
    Type: String
    Default: master
  InfrastructureTemplatePath:
    Type: String
    Default: infrastructure.yml
  InfrastructureStackName:
    Type: String
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Source Code Repository
        Parameters:
          - GithubRepoOwner
          - GithubRepoName
          - GithubRepoBranch
          - GithubOauthToken
Resources:
  ArtifactStoreBucket:
    Type: AWS::S3::Bucket
    Properties:
      VersioningConfiguration:
        Status: Enabled
      AccessControl: BucketOwnerFullControl
  Pipeline:
    Type: AWS::CodePipeline::Pipeline
    Properties:
      RoleArn: !GetAtt [PipelineRole, Arn]
      ArtifactStore:
        Location:
          Ref:
            ArtifactStoreBucket
        Type: S3
      Stages:
        - Name: Source
          Actions:
            - InputArtifacts: []
              Name: Source
              ActionTypeId:
                Category: Source
                Owner: ThirdParty
                Version: 1
                Provider: GitHub
              OutputArtifacts:
                - Name: SourceOutput
              Configuration:
                Owner: !Ref GithubRepoOwner
                Repo: !Ref GithubRepoName
                Branch: !Ref GithubRepoBranch
                OAuthToken: !Ref GithubOauthToken
              RunOrder: 1
        - Name: DeployInfrastructure
          Actions:
          - Name: CreateStack
            ActionTypeId:
              Category: Deploy
              Owner: AWS
              Provider: CloudFormation
              Version: '1'
            InputArtifacts:
              - Name: SourceOutput
            OutputArtifacts:
              - Name: DeployInfrastructureStackOutput
            Configuration:
              RoleArn: !GetAtt [InfrastructureStackRole, Arn]
              TemplatePath: !Sub "SourceOutput::${InfrastructureTemplatePath}"
              ActionMode: CREATE_UPDATE
              StackName: !Ref InfrastructureStackName
              OutputFileName: cfn.json
            RunOrder: 1
        - Name: DeployApp
          Actions:
          - Name: DeployFrontend
            ActionTypeId:
                Category: Invoke
                Owner: AWS
                Version: 1
                Provider: Lambda
            InputArtifacts:
              - Name: SourceOutput
              - Name: DeployInfrastructureStackOutput
            Configuration:
                FunctionName: !Ref DeployFrontendFunction
            RunOrder: 1
  PipelineRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          Effect: Allow
          Principal:
            Service: codepipeline.amazonaws.com
          Action: sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AdministratorAccess
  InfrastructureStackRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          Effect: Allow
          Principal:
            Service: cloudformation.amazonaws.com
          Action: sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AdministratorAccess

  DeployFrontendFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          var childProcess = require('child_process');
          var fs = require('fs');
          var AWS = require('aws-sdk');
          var codepipeline = new AWS.CodePipeline();
          var s3;

          // for NPM, it needs a writable home directory
          process.env.HOME = '/tmp';

          process.on('unhandledRejection', function(error, promise) {
            console.error("UNHANDLED REJECTION", error.stack);
          });


          exports.handler = function(event, context) {

          var job = event['CodePipeline.job'];
              s3 = new AWS.S3({
                "signatureVersion":"v4",
                "accessKeyId": job.data.artifactCredentials.accessKeyId,
                "secretAccessKey": job.data.artifactCredentials.secretAccessKey,
                "sessionToken": job.data.artifactCredentials.sessionToken
              });


              doAction(npmAction, event, context);
          }


            // run an action
          function doAction(actionFunction, event, context) {
              var promise;
              try {
                  console.log("doAction")
                  promise = actionFunction(event["CodePipeline.job"])
              } catch (e) {
                  console.log("rejected:" + e)
                  promise = Promise.reject(e);
              }

              handlePromise(promise, event, context);
          }

          // handle promise by notifying code pipeline
          function handlePromise(promise, event, context) {
              promise
              .then(function() {
                  console.log("Success!");

                  var params = {
                      jobId: event["CodePipeline.job"].id
                  };
                  codepipeline.putJobSuccessResult(params, function(err, data) {
                      if(err) {
                          context.fail(err);
                      } else {
                          context.succeed("Action complete.");
                      }
                  });
              }).catch( function(message) {
                      var m = JSON.stringify(message);
                      console.error("Failure: "+m);

                      console.log("failed 1");

                      var params = {
                          jobId: event["CodePipeline.job"].id,
                          failureDetails: {
                              message: m,
                              type: 'JobFailed',
                              externalExecutionId: context.invokeid
                          }
                      };

                      console.log("failed 2");

                      codepipeline.putJobFailureResult(params, function(err, data) {
                      console.log("failed 3");
                      console.log("failed 3", err, data, m);
                      context.fail(m);
                      });
                      console.log("failed 4");
              });
          }


          // return: promise
          function npmAction(jobDetails) {
              var artifactName = 'SourceOutput';
              var artifactZipPath = '/tmp/source.zip';
              var artifactExtractPath = '/tmp/source/';
              var sourceFrontendPath = artifactExtractPath + 'frontend/'
              var sourceFrontendBuildPath = sourceFrontendPath + 'build/'
              return downloadInputArtifact(jobDetails, artifactName, artifactZipPath)
                  .then(function () {
                      console.log("juhu");
                      return rmdir(artifactExtractPath);
                  }).then(function () {
                      return extractZip(artifactZipPath, artifactExtractPath);
                  }).then(function () {
                      return npmInstallAndBuild(sourceFrontendPath);
                  }).then(function () {
                      return downloadInputArtifact(jobDetails, 'DeployInfrastructureStackOutput', '/tmp/DeployInfrastructureStackOutput.zip')
                  }).then(function () {
                      return uploadBuildToWebsiteBucket(sourceFrontendBuildPath);
                  });
          }

          // get input artifact
          //
          // return: promise
          function downloadInputArtifact(jobDetails, artifactName, dest) {
              console.log("Downloading input artifact '" + artifactName + "' to '"+dest+"'");

              // Get the input artifact
              var artifact = null;
              jobDetails.data.inputArtifacts.forEach(function (a) {

                  if (a.name == artifactName) {
                      artifact = a;
                  }
              });

              if (artifact != null && artifact.location.type == 'S3') {
                  var params = {
                      Bucket: artifact.location.s3Location.bucketName,
                      Key: artifact.location.s3Location.objectKey
                  };
                  return getS3Object(params, dest);
              } else {
                  return Promise.reject("Unknown Source Type:" + JSON.stringify(sourceOutput));
              }
          }


          function getS3Object(params, dest) {
              return new Promise(function(resolve,reject) {
                  console.log("Getting S3 Object '" + params.Bucket+"/"+params.Key + "' to '"+dest+"'");
                  var file = fs.createWriteStream(dest);
                  s3.getObject(params)
                      .createReadStream()
                      .on('error', reject)
                      .pipe(file)
                      .on('close', resolve);
              });
          }

          function exec(command,options) {
              return new Promise(function (resolve, reject) {
                  var child = childProcess.exec(command,options);

                  var lastMessage = ""
                  child.stdout.on('data', function(data) {
                      lastMessage = data.toString('utf-8');
                      process.stdout.write(data);
                  });
                  child.stderr.on('data', function(data) {
                      lastMessage = data.toString('utf-8');
                      process.stderr.write(data);
                  });
                  child.on('close', function (code) {
                      if(!code) {
                          resolve(true);
                      } else {
                          reject("Error("+code+") - "+lastMessage);
                      }
                  });
              });
          }

          function rmdir(dir) {
              console.log("rmdir");
              if(!dir || dir == '/') {
                  throw new Error('Invalid directory '+dir);
              }

              console.log("Cleaning directory '"+dir+"'");
              return exec('rm -rf '+dir);
          }


          function extractZip(sourceZip,destDirectory) {
              return new Promise(function (resolve, reject) {
                  console.log("Extracting zip: '"+sourceZip+"' to '"+destDirectory+"'");
                  try {
                      fs.mkdirSync(destDirectory);
                      process.chdir(destDirectory);
                      childProcess.execSync('unzip -o ' + sourceZip, {encoding: 'utf-8'});
                      resolve(true);
                  } catch (e) {
                      reject(e);
                  }
              });
          }

          function npmInstallAndBuild(destDirectory) {
              return new Promise(function (resolve, reject) {
                  try {
                      process.chdir(destDirectory);
                      childProcess.execSync('npm install --progress=false ', {encoding: 'utf-8'});
                      childProcess.execSync('npm run build', {encoding: 'utf-8'});
                      resolve(true);
                  } catch (e) {
                      reject(e);
                  }
              });
          }

          function uploadBuildToWebsiteBucket(destDirectory) {
              return new Promise(function (resolve, reject) {
                  try {
                      process.chdir('/tmp');
                      childProcess.execSync('unzip -o /tmp/DeployInfrastructureStackOutput.zip');
                      config = JSON.parse(fs.readFileSync('/tmp/cfn.json'));
                      s3WebsiteBucketClient = new AWS.S3();

                      process.chdir(destDirectory);
                      var files = walkSync(destDirectory);
                      files.forEach(function(file) {
                          mimeType = childProcess.execSync("file -b --mime-type " + file, {encoding: 'utf-8'}).trim();
                          relativeFilePath = file.replace(destDirectory, '');
                          console.log(file, relativeFilePath, mimeType);
                          s3WebsiteBucketClient.putObject({
                              'Bucket': config['WebsiteBucket'],
                              'Key': relativeFilePath,
                              'Body': fs.createReadStream(file),
                              'ContentType': mimeType
                          }, function(err, data) {
                                if (err) {
                                  console.log(err);
                                } else {
                                  console.log('Success');
                                }
                          });
                        });


                      resolve(true);
                  } catch (e) {
                      reject(e);
                  }
              });
          }

          function walkSync(dir, filelist) {
            var path = path || require('path');
            files = fs.readdirSync(dir);
            filelist = filelist || [];
            files.forEach(function(file) {
              if (fs.statSync(path.join(dir, file)).isDirectory()) {
                filelist = walkSync(path.join(dir, file), filelist);
              }
              else {
                filelist.push(path.join(dir, file));
              }
            });
            return filelist;
          };
      Handler: index.handler
      Role: !GetAtt [DeployFrontendFunctionRole, Arn]
      Runtime: nodejs4.3
      Timeout: 300

  DeployFrontendFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AdministratorAccess
